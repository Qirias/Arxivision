// Based on https://github.com/DaveH355/clustered-shading

#version 450

#extension GL_EXT_scalar_block_layout : enable

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Cluster {
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[711];
};

layout (std430, binding = 0) restrict buffer ClusterBuffer {
    Cluster clusters[];
};

layout (std430, binding = 1) uniform FrustumBuffer {
    mat4 inverseProjection;
    uvec3 gridSize;
    uint padding0;
    uvec2 screenDimensions;
    float zNear;
    float zFar;
};

vec3 screenToView(vec2 screenCoord) {
    // Convert to NDC
    vec4 ndc = vec4(screenCoord / screenDimensions * 2.0 - 1.0, -1.0, 1.0);

    // Convert to view coordinates
    vec4 viewCoord = inverseProjection * ndc;
    viewCoord /= viewCoord.w;
    return viewCoord.xyz;
}

// Returns the intersection point of an infinite line and a
// plane perpendicular to the Z-axis
vec3 lineIntersectionWithZPlane(vec3 startPoint, vec3 endPoint, float zDistance) {
    vec3 direction = endPoint - startPoint;
    vec3 normal = vec3(0.0, 0.0, 1.0);
    
    float denominator = dot(normal, direction);
    if (abs(denominator) < 1e-6) {
        return vec3(0.0);
    }
    
    // Since startPoint is 0,0,0 we can skip finding its Z position
    // and we can simplify the (zDistance - dot(normal, startPoint))
    float t = zDistance / denominator;
    return startPoint + t * direction;
}

void main() {
    uint tileIndex = gl_WorkGroupID.x +
                    (gl_WorkGroupID.y * gl_NumWorkGroups.x) +
                    (gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y);
                    
    vec2 tileSize = screenDimensions / gridSize.xy;
    
    // tile in screen-space
    vec2 minTile_screenspace = gl_WorkGroupID.xy * tileSize;
    vec2 maxTile_screenspace = (gl_WorkGroupID.xy + 1) * tileSize;

    // convert tile to view space sitting on the near plane
    vec3 minTile = screenToView(minTile_screenspace);
    vec3 maxTile = screenToView(maxTile_screenspace);
    
    // Tiago Sousaâ€™s DOOM 2016 Siggraph presentation
    float planeNear = zNear * pow(zFar / zNear, gl_WorkGroupID.z / float(gl_NumWorkGroups.z));
    float planeFar  = zNear * pow(zFar / zNear, (gl_WorkGroupID.z + 1) / float(gl_NumWorkGroups.z));
    
    // The line goes from the eye position in view space (0, 0, 0)
    // through the min/max points of a tile to intersect with a given cluster's near-far planes
    vec3 minPointNear =
        lineIntersectionWithZPlane(vec3(0, 0, 0), minTile, planeNear);
    vec3 minPointFar =
        lineIntersectionWithZPlane(vec3(0, 0, 0), minTile, planeFar);
    vec3 maxPointNear =
        lineIntersectionWithZPlane(vec3(0, 0, 0), maxTile, planeNear);
    vec3 maxPointFar =
        lineIntersectionWithZPlane(vec3(0, 0, 0), maxTile, planeFar);

    vec3 minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
    vec3 maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

    // planeNear and planeFar are not needed I just put them there
    clusters[tileIndex].minPoint  = vec4(minPointAABB , planeNear);
    clusters[tileIndex].maxPoint  = vec4(maxPointAABB , planeFar);
}
