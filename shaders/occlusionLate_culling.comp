#version 450

layout (local_size_x = 256) in;

struct ObjectData {
    vec4 aabbMin;
    vec4 aabbMax;
};

layout (set = 0, binding = 0) uniform CameraData {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    mat4 invView;
} camera;

layout (set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
} objectBuffer;

layout (set = 0, binding = 2) uniform sampler2D depthPyramid;

layout (set = 0, binding = 3) buffer VisibilityBuffer {
    uint visibleIndices[];
} visibilityBuffer;

layout (set = 0, binding = 4) uniform GlobalData {
    vec4 frustum[6];  // Left/right/top/bottom frustum planes
    float zNear;
    float zFar;
    float P00;
    float P11;
    uint pyramidWidth;
    uint pyramidHeight;
    uint instances;
    vec4 _padding;
} globalData;


layout (set = 0, binding = 5) buffer drawVisibilityBuffer {
    uint at[];
} drawVisibility;

const float MAX_DEPTH = 1.0;
const float SAMPLE_STEP = 0.025; // This is a static sample step, adjust based on profiling

bool within(float lower, float value, float upper) {
    return value >= lower && value <= upper;
}

bool isFrustumVisible(vec3 aabbMin, vec3 aabbMax, mat4 VP) {
    vec3 boxCorners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };
    
    bool inside = false;
    for (int i = 0; i < 8; ++i) {
        vec4 clipCoord = VP * vec4(boxCorners[i], 1.0);
        inside = inside || (within(-clipCoord.w, clipCoord.x, clipCoord.w) &&
                            within(-clipCoord.w, clipCoord.y, clipCoord.w) &&
                            within(0.0, clipCoord.z, clipCoord.w));
    }
    
    return inside;
}

bool isVisibleAABB(vec3 aabbMin, vec3 aabbMax) {
    vec3 boxCenter = 0.5 * (aabbMin + aabbMax);

    // Check if the chunk is too close to the camera to skip frustum culling
    if (distance(vec3(camera.invView[3]), boxCenter) < 10.0f) {
        return true;
    }
    
    if (!isFrustumVisible(aabbMin, aabbMax, camera.viewProj)) {
        return false;  // Cull early if not within frustum
    }
    
    vec3 boxCorners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };
    float minDepth = 1.0;
    float maxDepth = 0.0;

    for (int i = 0; i < 8; i++) {
        vec4 clipCoord = camera.viewProj * vec4(boxCorners[i], 1.0);
        vec3 ndc = clipCoord.xyz / clipCoord.w; // Convert to NDC
        vec2 uv = ndc.xy * 0.5 + 0.5; // Convert NDC to UV coordinates
        uv = clamp(uv, vec2(0.0), vec2(1.0)); // Clamp to texture coordinates

        vec2 uvMin = ndc.xy * 0.5 + 0.5;
        vec2 uvMax = ndc.xy * 0.5 + 0.5;

        uvMin = clamp(uvMin, vec2(0.0, 0.0), vec2(1.0, 1.0));
        uvMax = clamp(uvMax, vec2(0.0, 0.0), vec2(1.0, 1.0));

        float width = (uvMax.x - uvMin.x) * float(globalData.pyramidWidth);
        float height = (uvMax.y - uvMin.y) * float(globalData.pyramidHeight);
        float lod = max(floor(log2(max(width, height))), 0.0);
        
        // Sample the depth pyramid
        float depth = textureLod(depthPyramid, uv, lod).r;

        // Keep track of the minimum and maximum depth found
        minDepth = min(minDepth, depth);
        maxDepth = max(maxDepth, depth);
    }

    // Compare the nearest and furthest Z-values in clip space
    vec4 clipMin = camera.viewProj * vec4(aabbMin, 1.0);
    vec4 clipMax = camera.viewProj * vec4(aabbMax, 1.0);
    float nearestZ = min(clipMin.z / clipMin.w, clipMax.z / clipMax.w);
    float furthestZ = max(clipMin.z / clipMin.w, clipMax.z / clipMax.w);

    return nearestZ <= maxDepth && furthestZ >= minDepth;
}


void main() {
    uint index = gl_GlobalInvocationID.x;
    bool visible;
    if (index < globalData.instances) {
        visible = isVisibleAABB(objectBuffer.objects[index].aabbMin.xyz, objectBuffer.objects[index].aabbMax.xyz);
        if (visible && drawVisibility.at[index] == 0) {
            visibilityBuffer.visibleIndices[index] = 1;
        }
        
        drawVisibility.at[index] = visible ? 1 : 0;
    }
}
