#version 450
 
 layout (local_size_x = 256) in;

 struct ObjectData {
     vec4 aabbMin;
     vec4 aabbMax;
 };

 layout (set = 0, binding = 0) uniform CameraData {
     mat4 view;
     mat4 proj;
     mat4 viewProj;
     mat4 invView;
 } camera;

 layout (set = 0, binding = 1) readonly buffer ObjectBuffer {
     ObjectData objects[];
 } objectBuffer;

 layout (set = 0, binding = 2) uniform sampler2D depthPyramid;

 layout (set = 0, binding = 3) buffer VisibilityBuffer {
     uint visibleIndices[];
 } visibilityBuffer;

 layout (set = 0, binding = 4) uniform GlobalData {
     vec4 frustum[6];  // Left/right/top/bottom frustum planes
     float zNear;
     float zFar;
     float P00;
     float P11;
     uint pyramidWidth;
     uint pyramidHeight;
     uint instances;
     vec4 _padding;
 } globalData;

layout (set = 0, binding = 5) uniform MiscData {
    int occlusionCulling;
    int frustumCulling;
} misc;

 const float MAX_DEPTH = 1.0;
 const float SAMPLE_STEP = 0.025; // This is a static sample step, adjust based on profiling

 bool within(float lower, float value, float upper) {
     return value >= lower && value <= upper;
 }

 bool isFrustumVisible(vec3 aabbMin, vec3 aabbMax, mat4 VP) {
     vec3 corners[8] = {
         vec3(aabbMin.x, aabbMin.y, aabbMin.z),
         vec3(aabbMax.x, aabbMin.y, aabbMin.z),
         vec3(aabbMin.x, aabbMax.y, aabbMin.z),
         vec3(aabbMax.x, aabbMax.y, aabbMin.z),
         vec3(aabbMin.x, aabbMin.y, aabbMax.z),
         vec3(aabbMax.x, aabbMin.y, aabbMax.z),
         vec3(aabbMin.x, aabbMax.y, aabbMax.z),
         vec3(aabbMax.x, aabbMax.y, aabbMax.z)
     };
     
     bool inside = false;
     for (int i = 0; i < 8; ++i) {
         vec4 clipCoord = VP * vec4(corners[i], 1.0);
         inside = inside || (within(-clipCoord.w, clipCoord.x, clipCoord.w) &&
                             within(-clipCoord.w, clipCoord.y, clipCoord.w) &&
                             within(0.0, clipCoord.z, clipCoord.w));
     }
     
     return inside;
 }

 bool isVisibleAABB(vec3 aabbMin, vec3 aabbMax) {
    vec3 center = 0.5 * (aabbMin + aabbMax);
    bool visible = true;

    // Check if the chunk is too close to the camera to skip frustum culling
    if (distance(vec3(camera.invView[3]), center) < 10.0f) {
        return true;
    }

    if (!isFrustumVisible(aabbMin, aabbMax, camera.viewProj) && misc.frustumCulling == 1) {
        return false;  // Cull early if not within frustum
    }

    vec3 corners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };

    vec2 uvMin = vec2(1.0);
    vec2 uvMax = vec2(0.0);

    float nearestDepth = 1.0f;

    for (int i = 0; i < 8; i++) {
        vec4 clipCoord = camera.viewProj * vec4(corners[i], 1.0);
        vec3 ndc = clipCoord.xyz / clipCoord.w;
        float clipZ = clipCoord.z / clipCoord.w;
        
        vec2 uv = vec2(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
        uv = clamp(uv, vec2(0.0), vec2(1.0));
        
        uvMin = min(uvMin, uv);
        uvMax = max(uvMax, uv);
        
        nearestDepth = min(nearestDepth, clipZ);
    }

    float width = (uvMax.x - uvMin.x) * float(globalData.pyramidWidth);
    float height = (uvMax.y - uvMin.y) * float(globalData.pyramidHeight);
    float lod = max(floor(log2(max(width, height))), 0.0);

    // Sample the depth pyramid
    float depth = textureLod(depthPyramid, (uvMin + uvMax) * 0.5, lod).x;

    visible = visible && nearestDepth <= depth || (misc.occlusionCulling == 0);
    
    return visible;
}

 void main() {
     uint index = gl_GlobalInvocationID.x;
     bool visible;
     if (index < globalData.instances) {
         visible = isVisibleAABB(objectBuffer.objects[index].aabbMin.xyz, objectBuffer.objects[index].aabbMax.xyz);
         visibilityBuffer.visibleIndices[index] = visible ? 1 : 0;
     }
 }
