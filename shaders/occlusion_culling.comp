#version 450

#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 256) in;

struct ObjectData {
    vec4 aabbMin;
    vec4 aabbMax; // w component stores the instanceCount
};

struct IndirectDrawCommand
{
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
    uint    drawID;
    uint    _padding[2];
};

layout(set = 0, binding = 0) uniform CameraData {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    mat4 invView;
} camera;

layout(set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
};

layout(set = 0, binding = 2) uniform sampler2D depthPyramid;

layout(set = 0, binding = 3) buffer VisibilityBuffer {
    uint visibleIndices[];
};

layout(set = 0, binding = 4) uniform GlobalData {
    vec4 frustum[6];  // Left/right/top/bottom frustum planes
    float zNear;
    float zFar;
    float P00;
    float P11;
    uint pyramidWidth;
    uint pyramidHeight;
    uint chunkCount;
    uint _padding;
} globalData;

layout(set = 0, binding = 5) uniform MiscData {
    int occlusionCulling;
    int frustumCulling;
} misc;

layout(set = 0, binding = 6) buffer DrawCommands {
    IndirectDrawCommand drawCommands[];
};

layout(set = 0, binding = 7) readonly buffer InstanceOffsets {
    uint64_t instanceOffsets[];
};

layout(set = 0, binding = 8) buffer DrawCommandCount {
    uint drawCommandCount;
};

bool within(float lower, float value, float upper) {
    return value >= lower && value <= upper;
}

bool isFrustumVisible(vec3 aabbMin, vec3 aabbMax, mat4 VP) {
    vec3 corners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };
    
    bool inside = false;
    for (int i = 0; i < 8; ++i) {
        vec4 clipCoord = VP * vec4(corners[i], 1.0);
        inside = inside || (within(-clipCoord.w, clipCoord.x, clipCoord.w) &&
                            within(-clipCoord.w, clipCoord.y, clipCoord.w) &&
                            within(0.0, clipCoord.z, clipCoord.w));
    }
    
    return inside;
}

bool isVisibleAABB(vec3 aabbMin, vec3 aabbMax) {
    vec3 center = 0.5 * (aabbMin + aabbMax);
    bool visible = true;

    if (distance(vec3(camera.invView[3]), center) < 15.0f) {
        return true;
    }

    if (!isFrustumVisible(aabbMin, aabbMax, camera.viewProj) && misc.frustumCulling == 1) {
        return false;
    }

    vec3 corners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };

    vec2 uvMin = vec2(1.0);
    vec2 uvMax = vec2(0.0);

    float nearestDepth = 1.0f;

    for (int i = 0; i < 8; i++) {
        vec4 clipCoord = camera.viewProj * vec4(corners[i], 1.0);
        vec3 ndc = clipCoord.xyz / clipCoord.w;
        float clipZ = clipCoord.z / clipCoord.w;
        
        vec2 uv = vec2(ndc.x * 0.5 + 0.5, ndc.y * 0.5 + 0.5);
        uv = clamp(uv, vec2(0.0), vec2(1.0));
        
        uvMin = min(uvMin, uv);
        uvMax = max(uvMax, uv);
        
        nearestDepth = min(nearestDepth, clipZ);
    }

    float width = (uvMax.x - uvMin.x) * float(globalData.pyramidWidth);
    float height = (uvMax.y - uvMin.y) * float(globalData.pyramidHeight);
    float lod = max(floor(log2(max(width, height))), 0.0);

    float depth = textureLod(depthPyramid, (uvMin + uvMax) * 0.5, lod).x;

    visible = visible && nearestDepth <= depth || (misc.occlusionCulling == 0);
    
    return visible;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= globalData.chunkCount) return;

    bool visible = isVisibleAABB(objects[index].aabbMin.xyz, objects[index].aabbMax.xyz);

    // Update the draw command
    if (visible && visibleIndices[index] == 0) {
        uint drawCommandIndex = atomicAdd(drawCommandCount, 1);
        
        drawCommands[drawCommandIndex].drawID = index;
        drawCommands[drawCommandIndex].indexCount = 36;
        drawCommands[drawCommandIndex].instanceCount = uint(objects[index].aabbMax.w);
        drawCommands[drawCommandIndex].firstIndex = 0;
        drawCommands[drawCommandIndex].vertexOffset = 0;
        drawCommands[drawCommandIndex].firstInstance = uint(instanceOffsets[index]);
    }
    
    visibleIndices[index] = visible ? 1 : 0;
}
