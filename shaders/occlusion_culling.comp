#version 450

layout (local_size_x = 256) in;

struct ObjectData {
    vec4 aabbMin;
    vec4 aabbMax;
};

layout (set = 0, binding = 0) uniform CameraData {
    mat4 viewProj;
    mat4 invView;
} camera;

layout (set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
} objectBuffer;

layout (set = 0, binding = 2) uniform sampler2D depthPyramid;

layout (set = 0, binding = 3) buffer VisibilityBuffer {
    uint visibleIndices[];
} visibilityBuffer;

layout (set = 0, binding = 4) uniform GlobalData {
    uint pyramidWidth;
    uint pyramidHeight;
    uint instances;
    uint padding;
} globalData;


const float MAX_DEPTH = 1.0;
const float SAMPLE_STEP = 0.025; // This is a static sample step, adjust based on profiling

bool within(float lower, float value, float upper) {
    return value >= lower && value <= upper;
}

bool isFrustumVisible(vec3 aabbMin, vec3 aabbMax, mat4 VP) {
    vec3 boxCorners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };
    
    bool inside = false;
    for (int i = 0; i < 8; ++i) {
        vec4 clipCoord = VP * vec4(boxCorners[i], 1.0);
        inside = inside || (within(-clipCoord.w, clipCoord.x, clipCoord.w) &&
                            within(-clipCoord.w, clipCoord.y, clipCoord.w) &&
                            within(0.0, clipCoord.z, clipCoord.w));
    }
    
    return inside;
}

bool isVisibleAABB(vec3 aabbMin, vec3 aabbMax) {
    vec3 boxCenter = 0.5 * (aabbMin + aabbMax);

    // Check if the chunk is too close to the camera to skip frustum culling
    if (distance(vec3(camera.invView[3]), boxCenter) < 10.0f) {
        return true;
    }
    
    if (!isFrustumVisible(aabbMin, aabbMax, camera.viewProj)) {
        return false;  // Cull early if not within frustum
    }
    else
        return true;
        
    vec3 boxHalfExtents = 0.5 * (aabbMax - aabbMin);

    vec4 clipMin = camera.viewProj * vec4(boxCenter - boxHalfExtents, 1.0);
    vec4 clipMax = camera.viewProj * vec4(boxCenter + boxHalfExtents, 1.0);

    vec3 clipMinNDC = clipMin.xyz / clipMin.w;
    vec3 clipMaxNDC = clipMax.xyz / clipMax.w;

    vec2 uvMin = clipMinNDC.xy * 0.5 + 0.5;
    vec2 uvMax = clipMaxNDC.xy * 0.5 + 0.5;

    uvMin = clamp(uvMin, vec2(0.0, 0.0), vec2(1.0, 1.0));
    uvMax = clamp(uvMax, vec2(0.0, 0.0), vec2(1.0, 1.0));

    float width = (uvMax.x - uvMin.x) * float(globalData.pyramidWidth);
    float height = (uvMax.y - uvMin.y) * float(globalData.pyramidHeight);
    float lod = max(floor(log2(max(width, height))), 0.0);

    float minDepth = MAX_DEPTH;
    for (float u = uvMin.x; u <= uvMax.x; u += SAMPLE_STEP) {
        for (float v = uvMin.y; v <= uvMax.y; v += SAMPLE_STEP) {
            float depth = textureLod(depthPyramid, vec2(u, v), lod).r;
            minDepth = min(minDepth, depth);
        }
    }

    return (clipMax.z / clipMax.w) <= minDepth;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index < globalData.instances) {
        visibilityBuffer.visibleIndices[index] = isVisibleAABB(objectBuffer.objects[index].aabbMin.xyz, objectBuffer.objects[index].aabbMax.xyz) ? 1 : 0;
    }
}
