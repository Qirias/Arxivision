#version 450

#extension GL_ARB_gpu_shader_int64 : enable

layout(local_size_x = 256) in;

struct ObjectData {
    vec4 aabbMin;
    vec4 aabbMax; // w component stores the instanceCount
};

struct IndirectDrawCommand
{
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
    uint    drawID;
    uint    _padding[2];
};

layout(set = 0, binding = 0) uniform CameraData {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    mat4 invView;
} camera;

layout(set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
};

layout(set = 0, binding = 2) uniform sampler2D depthPyramid;

layout(set = 0, binding = 3) buffer VisibilityBuffer {
    uint visibleIndices[];
};

layout(set = 0, binding = 4) uniform GlobalData {
    vec4 frustum[6];  // Left/right/top/bottom frustum planes
    float zNear;
    float zFar;
    float P00;
    float P11;
    uint pyramidWidth;
    uint pyramidHeight;
    uint chunkCount;
    uint _padding;
} globalData;

layout(set = 0, binding = 5) uniform MiscData {
    int occlusionCulling;
    int frustumCulling;
} misc;

layout(set = 0, binding = 6) buffer DrawCommands {
    IndirectDrawCommand drawCommands[];
};

layout(set = 0, binding = 7) readonly buffer InstanceOffsets {
    uint64_t instanceOffsets[];
};

layout(set = 0, binding = 8) buffer DrawCommandCount {
    uint drawCommandCount;
};

const float MAX_DEPTH = 1.0;

bool within(float lower, float value, float upper) {
    return value >= lower && value <= upper;
}

bool isFrustumVisible(vec3 aabbMin, vec3 aabbMax, mat4 VP) {
    vec3 corners[8] = {
        vec3(aabbMin.x, aabbMin.y, aabbMin.z),
        vec3(aabbMax.x, aabbMin.y, aabbMin.z),
        vec3(aabbMin.x, aabbMax.y, aabbMin.z),
        vec3(aabbMax.x, aabbMax.y, aabbMin.z),
        vec3(aabbMin.x, aabbMin.y, aabbMax.z),
        vec3(aabbMax.x, aabbMin.y, aabbMax.z),
        vec3(aabbMin.x, aabbMax.y, aabbMax.z),
        vec3(aabbMax.x, aabbMax.y, aabbMax.z)
    };
    
    bool inside = false;
    for (int i = 0; i < 8; ++i) {
        vec4 clipCoord = VP * vec4(corners[i], 1.0);
        inside = inside || (within(-clipCoord.w, clipCoord.x, clipCoord.w) &&
                            within(-clipCoord.w, clipCoord.y, clipCoord.w) &&
                            within(0.0, clipCoord.z, clipCoord.w));
    }
    
    return inside;
}

bool isVisibleAABB(vec3 aabbMin, vec3 aabbMax) {
    vec3 center = 0.5 * (aabbMin + aabbMax);
    bool visible = true;

    if (distance(vec3(camera.invView[3]), center) < 20.0f) {
        return true;
    }

    if (!isFrustumVisible(aabbMin, aabbMax, camera.viewProj) && misc.frustumCulling == 1) {
        return false;
    }

    visible = visible || (misc.occlusionCulling == 0);
    
    return visible;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= globalData.chunkCount) return;
    
    if (visibleIndices[index] == 0)
        return;

    bool visible = isVisibleAABB(objects[index].aabbMin.xyz, objects[index].aabbMax.xyz);

    // Update the draw command
    if (visible) {
        uint drawCommandIndex = atomicAdd(drawCommandCount, 1);
        
        drawCommands[drawCommandIndex].drawID = index;
        drawCommands[drawCommandIndex].indexCount = 36;
        drawCommands[drawCommandIndex].instanceCount = uint(objects[index].aabbMax.w);
        drawCommands[drawCommandIndex].firstIndex = 0;
        drawCommands[drawCommandIndex].vertexOffset = 0;
        drawCommands[drawCommandIndex].firstInstance = uint(instanceOffsets[index]);
    }
}
