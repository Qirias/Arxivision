#version 450

#define LOCAL_SIZE 128
layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

struct PointLight {
    vec3 position;
    uint visibilityMask;
    vec4 color;
};

struct Cluster {
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[127];
};

layout (std430, binding = 0) restrict buffer ClusterBuffer {
    Cluster clusters[];
};

layout (std140, binding = 1) readonly buffer PointLightsBuffer {
    PointLight pointLights[];
};

layout (binding = 2) uniform ViewMatrix {
    mat4 viewMatrix;
};

layout (binding = 3) uniform LightCountBuffer {
    uint lightCount;
};

// AABB-AABB intersection test
bool aabbIntersection(vec3 minA, vec3 maxA, vec3 minB, vec3 maxB) {
    return (minA.x <= maxB.x && maxA.x >= minB.x) &&
           (minA.y <= maxB.y && maxA.y >= minB.y) &&
           (minA.z <= maxB.z && maxA.z >= minB.z);
}

bool testLightAABB(uint i, Cluster cluster) {
    vec3 lightCenter = vec3(viewMatrix * vec4(pointLights[i].position, 1.0));
    
    vec3 lightExtent = vec3(0.866); // sqrt(3) * 0.5

    // Calculate light AABB in view space
    vec3 lightMin = lightCenter - lightExtent;
    vec3 lightMax = lightCenter + lightExtent;

    vec3 clusterMin = cluster.minPoint.xyz;
    vec3 clusterMax = cluster.maxPoint.xyz;

    return aabbIntersection(lightMin, lightMax, clusterMin, clusterMax);
}

void main()
{
    uint index = gl_WorkGroupID.x * LOCAL_SIZE + gl_LocalInvocationID.x;
    Cluster cluster = clusters[index];

    cluster.count = 0;

    for (uint i = 0; i < lightCount; ++i)
    {
        if (pointLights[i].visibilityMask == 0) continue;
        
        if (testLightAABB(i, cluster) && cluster.count < 127)
        {
            cluster.lightIndices[cluster.count] = i;
            cluster.count++;
        }
    }
    clusters[index] = cluster;
}
