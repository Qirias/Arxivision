#version 450

#define LOCAL_SIZE 128
layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

struct PointLight {
    vec3 position;
    uint visibilityMask;
    vec4 color;
};

struct Cluster {
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[311];
};

layout (std430, binding = 0) restrict buffer ClusterBuffer {
    Cluster clusters[];
};

layout (std140, binding = 1) readonly buffer PointLightsBuffer {
    PointLight pointLights[];
};

layout (binding = 2) uniform ViewMatrix {
    mat4 viewMatrix;
};

layout (binding = 3) uniform LightCountBuffer {
    uint lightCount;
};

bool testLightAABB(uint i, Cluster cluster) {
    vec3 lightPos = pointLights[i].position;
    float radius = 3.5;

    // Transform light position to view space
    vec3 viewLightPos = vec3(viewMatrix * vec4(lightPos, 1.0));

    vec3 clusterMin = cluster.minPoint.xyz;
    vec3 clusterMax = cluster.maxPoint.xyz;

    // Check if the light's bounding sphere intersects the cluster's AABB
    vec3 closestPoint = max(clusterMin, min(viewLightPos, clusterMax));
    float distanceSquared = dot(closestPoint - viewLightPos, closestPoint - viewLightPos);

    return distanceSquared <= (radius * radius);
}

void main()
{
    uint index = gl_WorkGroupID.x * LOCAL_SIZE + gl_LocalInvocationID.x;
    Cluster cluster = clusters[index];

    cluster.count = 0;

    for (uint i = 0; i < lightCount; ++i)
    {
        if (pointLights[i].visibilityMask == 0) continue;
        
        if (testLightAABB(i, cluster) && cluster.count < 255)
        {
            cluster.lightIndices[cluster.count] = i;
            cluster.count++;
        }
    }
    clusters[index] = cluster;
}
