#version 450
#extension GL_GOOGLE_include_directive : require
#include "common_structs.glsl"

#define LOCAL_SIZE 128
layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;


layout (std430, binding = 0) restrict buffer ClusterLightsBuffer {
    ClusterLights clusterLights[];
};

layout (std430, binding = 1) restrict buffer ClusterBoundsBuffer {
    ClusterBounds clusterBounds[];
};

layout (std140, binding = 2) readonly buffer PointLightsBuffer {
    PointLight pointLights[];
};

layout (binding = 3) uniform ViewMatrix {
    mat4 viewMatrix;
};

layout (binding = 4) uniform LightCountBuffer {
    uint lightCount;
};

layout (binding = 5) uniform MaxLightDistance {
    float maxDistance;
};

bool testLightAABB(uint i, ClusterBounds clusterBound) {
    float radius = maxDistance*DIFFUSE_MULTIPLIER; // diffuse has maxDistance of 3 times more

    vec3 viewLightPos = vec3(viewMatrix * vec4(pointLights[i].position, 1.0));

    // Check if the light's bounding sphere intersects the cluster's AABB
    // Basically clamping
    vec3 closestPoint = max(clusterBound.minPoint.xyz, min(viewLightPos, clusterBound.maxPoint.xyz));
    float distanceSquared = dot(closestPoint - viewLightPos, closestPoint - viewLightPos);

    return distanceSquared <= (radius * radius);
}

void main()
{
    uint index = gl_WorkGroupID.x * LOCAL_SIZE + gl_LocalInvocationID.x;
    ClusterLights clusterLight = clusterLights[index];
    ClusterBounds clusterBound = clusterBounds[index];

    clusterLight.count = 0;

    for (uint i = 0; i < lightCount; ++i)
    {
        if (pointLights[i].visibilityMask == 0) continue;
        
        if (testLightAABB(i, clusterBound) && clusterLight.count < 711)
        {
            clusterLight.lightIndices[clusterLight.count] = i;
            clusterLight.count++;
        }
    }
    clusterLights[index] = clusterLight;
    clusterBounds[index] = clusterBound;
}
